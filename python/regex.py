#! /usr/bin/env python3
# -*- coding: utf-8 -*-

'''
	regex
	正则表达式是一种用来匹配字符串的工具
'''
'''
	例子：
		判断一个字符串是否是合法的Email的方法是：
		1. 创建一个匹配Email的正则表达式
		2. 用该正则表达式取匹配用户的输入来判断是否合法
'''
'''
	\d 可以匹配一个数字
	\w 可以匹配一个字母或数字
	\s 可以匹配一个空格（也包括 Tab 等空白符）
	
	'00\d' 可以匹配'007'，但无法匹配 '00A'
	'\d\d\d' 可以匹配 '010'
	'\w\w\d' 可以匹配 'py3'
-----------------------------------------------
	. 可以匹配任意字符
	
	'py.' 可以匹配 'pyc', 'pyo' 等
-----------------------------------------------
	要匹配变长的字符，在正则表达式中，要 * 表示任意个字符（包括0个），
	用 + 表示至少一个字符，用 ？ 表示0个或1个字符，用 {n} 表示n个字符，
	用 {n, m} 表示 n-m 个字符

	\d{3}\s+\d{3,8}
	1. \d{3} 表示匹配 3 个数字，例如 '010'
	2. \s 可以匹配一个空格（也包括Tab等空白符），所以 \s+ 表示至少有一个
	空格，例如匹配 ' ', ' '等
	3. \d{3,8} 表示 3-8 个数字，例如 '1234567'
	综合，上面的正则表达式可以匹配以任意个空格隔开的带区号的电话号码
	
	如果要匹配 '010-12345' 这样的号码呢？
	由于 '-' 是特殊字符，在正则表达式中，要用 '\' 转义，所以，
	上面的正则是 \d{3}\-\d{3,8}，但仍然无法匹配 '010 - 12345'。
'''

'''
	进阶
'''
'''
	做更精确地匹配，可以用 [] 表示范围，比如
	[0-9a-zA-Z\_] 可以匹配一个数字，字母或者下划线

	[0-9a-zA-Z\_]+ 可以匹配至少由一个数字，字母或者下划线组成的字符串，
	比如 'a100','0_Z', 'Py3000'等
	
	[a-zA-Z\_][0-9a-zA-Z\_]* 可以匹配由字母或下划线开头，后接任意个由一个
	数字，字母或者下划线组成的字符串，也就是Python合法的变量

	[a-zA-Z\_][0-9a-zA-Z\_]{0, 19} 更精确地限制了变量的长度是1-20个字符
	（前面1个字符+后面最多19个字符）
'''
'''
	A|B 可以匹配 A 或 B，所以（P|p)ython 可以匹配 'Python' 或者 'python'
	^ 表示行的开头，^\d 表示必须以数字开头
	$ 表示行的结束, \d$ 表示必须以数字结束
'''

'''	
	re模块
		Python提供re模块，包含所有正则表达式的功能。
		由于Python的字符串本身也用 \ 转义	
'''

# Python的字符串
s = 'ABC\\-001'
# 对应的正则表达式字符串变成
print(s)

# 强烈建议使用Python的 r 前缀，就不用考虑转义
s = r'ABC\-001' # Python的字符串
print(s) # 对应的正则表达式字符串不变：'ABC\-001'

import re
test = '010-12345'
if re.match(r'^\d{3}\-\d{3,8}$', test):
	print('ok')
else:
	print('failed')

'''
	切分字符串
'''
# 以空格切分字符串，但无法识别连续的空格
print('a b  c'.split(' '))
# 使用正则表达式
print(re.split(r'\s+', 'a b  c'))
# 无论多少个空格都可以正常分隔。加入“，”
print(re.split(r'[\s\,]+', 'a,b, c  d'))
# 在加入“；”
print(re.split(r'[\s\,\;]+', 'a,b;; c  d'))

'''
	分组

	除了简单地判断是否匹配之外，正则表达式还有提取子串的功能。
	用 () 表示的就是要提取的分组（Group）。
'''
'''
	^(\d{3})-(\d{3,8})$ 分别定义了两个组，
	可以直接从匹配的字符串中提取出区号和本地号码
'''

m = re.match(r'^(\d{3})-(\d{3,8})$', '010-12345')
print(m)
print(m.group(0))
print(m.group(1))
print(m.group(2))

# 注意到 group(0) 永远是原始字符串，group(1),group(2)....表示第1，2...个子串

t = '19:05:30'
m = re.match(r'^(0[0-9]|1[0-9]|2[0-3]|[0-9])\:(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|[0-9])\:(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|[0-9])$', t)
print(m.groups())

# 识别日期
d = '12-20'
m = re.match(r'^(0[1-9]|1[0-2]|[0-9])-(0[1-9]|1[0-9]|2[0-9]|3[0-1]|[0-9])$', d)
print(m.groups())

# 注 对于'2-30','4-31'这样的非法日期，用正则还是识别不了


'''
	贪婪匹配
	
	正则匹配默认是贪婪匹配，也就是匹配尽可能多的字符
'''
print(re.match(r'^(\d+)(0*)$', '102300').groups())

'''
	由于 \d+ 采用贪婪匹配，直接把后面的 0 全部匹配，结果 0*只能匹配空字符串
	
	让 \d+ 采用非贪婪匹配（也就是尽可能少匹配），才能把后面的 0 匹配出来，
	加个 ？ 就可以让 \d+ 采用非贪婪匹配
'''
print(re.match(r'^(\d+?)(0*)$', '102300').groups())

'''
	编译
	
	Python中使用正则表达式时，re模块内部会干两件事情：
	1. 编译正则表达式，如果正则表达式的字符串本身不合法，会报错
	2. 用编译后的正则表达式去匹配字符串

	如果一个正则表达式要重复使用几千次，处于效率的考虑，
	我们可以预编译该正则表达式，接下来重复使用就不需要编译这个步骤了，直接匹配
'''

# 编译
re_telephone = re.compile(r'^(\d{3})-(\d{3,8})$')

# 使用
print(re_telephone.match('010-12345').groups())
print(re_telephone.match('010-8086').groups())

'''
	编译后生成Regular Expression对象，由于该对象自己包含了正则表达式，
	所以调用对应的方法时不用给出正则字符串
'''
